import org.gradle.api.GradleException
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.testing.Test
import org.gradle.jvm.toolchain.JavaLanguageVersion

plugins {
    base
    id("org.springframework.boot") version "3.5.7" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("com.google.protobuf") version "0.9.4" apply false
}

allprojects {
    version = "0.0.1-SNAPSHOT"

    repositories {
        mavenCentral()
    }
}

subprojects {
    plugins.withType(JavaPlugin::class.java) {
        extensions.configure(JavaPluginExtension::class.java) {
            toolchain.languageVersion.set(JavaLanguageVersion.of(21))
        }
    }

    tasks.withType(Test::class.java).configureEach {
        useJUnitPlatform()
    }

    tasks.withType(JavaCompile::class.java).configureEach {
        options.compilerArgs.add("-parameters")
    }
}

val congressCliAvailable = file("tools/congress-cli").isDirectory

if (congressCliAvailable) {
    val buildTools = tasks.register("buildTools") {
        dependsOn(":tools:congress-cli:assembleToolDistribution")
    }

    tasks.named("build") {
        dependsOn(buildTools)
    }
} else {
    tasks.register("buildTools") {
        group = "build"
        description = "Builds the congress CLI distribution when the tools/congress-cli module is available."
        doLast {
            throw GradleException("The tools/congress-cli module is not available in this environment.")
        }
    }
}

tasks.register("prepareDockerEnv") {
    group = "docker"
    description = "Generates environment variables for docker-compose from gradle.properties."
    doLast {
        val apiKey = findProperty("CONGRESS_API_KEY")?.toString()?.takeIf { it.isNotBlank() }
                ?: throw GradleException("CONGRESS_API_KEY is not set. Add it to gradle.properties to run docker-compose.")
        val openAiKey = findProperty("OPENAI_API_KEY")?.toString()?.takeIf { it.isNotBlank() }
                ?: throw GradleException("OPENAI_API_KEY is not set. Add it to gradle.properties to run docker-compose.")

        val outputFile = layout.projectDirectory.file("build/docker/ingest-usa-fed.env").asFile
        outputFile.parentFile.mkdirs()
        val content = buildString {
            appendLine("CONGRESS_API_KEY=$apiKey")
            appendLine("OPENAI_API_KEY=$openAiKey")
        }
        outputFile.writeText(content)
        logger.lifecycle("Wrote docker-compose env file to ${outputFile.relativeTo(layout.projectDirectory.asFile)}")
    }
}

tasks.register("generateServiceMesh") {
    group = "documentation"
    description = "Generates service dependency mesh documentation into services/README.md."
    val outputFile = layout.projectDirectory.file("services/README.md")
    outputs.file(outputFile)

    doLast {
        // Discover all Gradle subprojects that represent deployable services.
        val serviceProjects = rootProject.subprojects
            .filter { it.path.startsWith(":services:") }
            .sortedBy { it.name }
        val servicePaths = serviceProjects.map { it.path }.toSet()

        // Collect service-to-service dependencies by inspecting project dependencies for each configuration.
        val mesh = serviceProjects.associateWith { project ->
            val deps = mutableSetOf<org.gradle.api.Project>()
            project.configurations.forEach { configuration ->
                configuration.dependencies
                    .withType(ProjectDependency::class.java)
                    .forEach { dependency: ProjectDependency ->
                        val dependencyProject = rootProject.findProject(dependency.path)
                        if (dependencyProject != null && dependencyProject.path in servicePaths && dependencyProject != project) {
                            deps += dependencyProject
                        }
                    }
            }
            deps.toList().sortedBy { it.name }
        }

        // Emit markdown with both a tabular view and a Mermaid graph for quick visualization.
        val builder = StringBuilder()
        builder.appendLine("# Cloud Services")
        builder.appendLine()
        builder.appendLine("> Generated by `./gradlew generateServiceMesh`. Do not edit manually.")
        builder.appendLine()
        builder.appendLine("The `services/` directory contains every deployable backend workload that powers Beacon. Each subdirectory is a Spring Boot microservice with its own Dockerfile, infrastructure configuration, and Gradle module.")
        builder.appendLine()
        builder.appendLine("## Active Services")
        builder.appendLine()
        builder.appendLine("| Service | Version | Consumes Services |")
        builder.appendLine("| --- | --- | --- |")
        serviceProjects.forEach { project ->
            val dependsOn = mesh.getValue(project)
            val displayDependencies = if (dependsOn.isEmpty()) "_None_" else dependsOn.joinToString(", ") { "`${it.name}`" }
            val version = project.version.toString().ifBlank { "unspecified" }
            builder.appendLine("| `${project.name}` | $version | $displayDependencies |")
        }
        builder.appendLine()
        builder.appendLine("```mermaid")
        builder.appendLine("graph TD")
        val nodeIds = mutableMapOf<org.gradle.api.Project, String>()
        serviceProjects.forEachIndexed { index, project ->
            val nodeId = "S$index"
            nodeIds[project] = nodeId
            val label = "${project.name} ${project.version}".trim()
            builder.appendLine("    $nodeId[\"$label\"]")
        }
        mesh.forEach { (project, dependencies) ->
            dependencies.forEach { dependency ->
                builder.appendLine("    ${nodeIds.getValue(project)} --> ${nodeIds.getValue(dependency)}")
            }
        }
        builder.appendLine("```")
        builder.appendLine()
        builder.appendLine("Run `./gradlew generateServiceMesh` after modifying inter-service dependencies to refresh this document.")

        outputFile.asFile.writeText(builder.toString())
        logger.lifecycle("Wrote service dependency mesh documentation to ${outputFile.asFile.relativeTo(rootProject.projectDir)}")
    }
}
