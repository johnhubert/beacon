import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.testing.Test
import org.gradle.jvm.toolchain.JavaLanguageVersion

plugins {
    base
    id("org.springframework.boot") version "3.5.7" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("com.google.protobuf") version "0.9.4" apply false
}

allprojects {
    version = "0.0.1-SNAPSHOT"

    repositories {
        mavenCentral()
    }
}

subprojects {
    plugins.withType(JavaPlugin::class.java) {
        extensions.configure(JavaPluginExtension::class.java) {
            toolchain.languageVersion.set(JavaLanguageVersion.of(21))
        }
    }

    tasks.withType(Test::class.java).configureEach {
        useJUnitPlatform()
    }

    tasks.withType(JavaCompile::class.java).configureEach {
        options.compilerArgs.add("-parameters")
    }
}

fun Project.serviceProjects(): List<Project> =
    rootProject.subprojects
        .filter { it.path.startsWith(":services:") }
        .sortedBy { it.name }

fun Project.serviceMesh(serviceProjects: List<Project>): Map<Project, List<Project>> {
    val servicePaths = serviceProjects.map { it.path }.toSet()
    return serviceProjects.associateWith { project ->
        val dependencies = mutableSetOf<Project>()
        project.configurations.forEach { configuration ->
            configuration.dependencies.withType(ProjectDependency::class.java)
                .forEach { dependency: ProjectDependency ->
                    val dependencyProject = rootProject.findProject(dependency.path)
                    if (dependencyProject != null && dependencyProject.path in servicePaths && dependencyProject != project) {
                        dependencies += dependencyProject
                    }
                }
        }
        dependencies.sortedBy { it.name }
    }
}

fun formatInfraLabel(key: String, explicitLabels: Map<String, String>): String =
    explicitLabels[key] ?: key.split('-', '_')
        .joinToString(" ") { segment ->
            segment.replaceFirstChar { if (it.isLowerCase()) it.uppercaseChar() else it }
        }

data class ComposeServiceInfo(
    val name: String,
    var containerName: String? = null,
    var dockerfile: String? = null,
    val dependsOn: MutableSet<String> = mutableSetOf(),
    val inferredInfra: MutableSet<String> = mutableSetOf()
)

val congressCliAvailable = file("tools/congress-cli").isDirectory

if (congressCliAvailable) {
    val buildTools = tasks.register("buildTools") {
        dependsOn(":tools:congress-cli:assembleToolDistribution")
    }

    tasks.named("build") {
        dependsOn(buildTools)
    }
} else {
    tasks.register("buildTools") {
        group = "build"
        description = "Builds the congress CLI distribution when the tools/congress-cli module is available."
        doLast {
            throw GradleException("The tools/congress-cli module is not available in this environment.")
        }
    }
}

tasks.register("prepareDockerEnv") {
    group = "docker"
    description = "Generates environment variables for docker-compose from gradle.properties."
    doLast {
        val apiKey = findProperty("CONGRESS_API_KEY")?.toString()?.takeIf { it.isNotBlank() }
                ?: throw GradleException("CONGRESS_API_KEY is not set. Add it to gradle.properties to run docker-compose.")
        val openAiKey = findProperty("OPENAI_API_KEY")?.toString()?.takeIf { it.isNotBlank() }
                ?: throw GradleException("OPENAI_API_KEY is not set. Add it to gradle.properties to run docker-compose.")

        val outputFile = layout.projectDirectory.file("build/docker/ingest-usa-fed.env").asFile
        outputFile.parentFile.mkdirs()
        val content = buildString {
            appendLine("CONGRESS_API_KEY=$apiKey")
            appendLine("OPENAI_API_KEY=$openAiKey")
        }
        outputFile.writeText(content)
        logger.lifecycle("Wrote docker-compose env file to ${outputFile.relativeTo(layout.projectDirectory.asFile)}")
    }
}

tasks.register("generateServiceMesh") {
    group = "documentation"
    description = "Generates service dependency mesh documentation into services/README.md."
    val outputFile = layout.projectDirectory.file("services/README.md")
    outputs.file(outputFile)

    doLast {
        val serviceProjects = serviceProjects()
        val mesh = serviceMesh(serviceProjects)

        // Emit markdown with both a tabular view and a Mermaid graph for quick visualization.
        val builder = StringBuilder()
        builder.appendLine("# Cloud Services")
        builder.appendLine()
        builder.appendLine("> Generated by `./gradlew generateServiceMesh`. Do not edit manually.")
        builder.appendLine()
        builder.appendLine("The `services/` directory contains every deployable backend workload that powers Beacon. Each subdirectory is a Spring Boot microservice with its own Dockerfile, infrastructure configuration, and Gradle module.")
        builder.appendLine()
        builder.appendLine("## Active Services")
        builder.appendLine()
        builder.appendLine("| Service | Version | Consumes Services |")
        builder.appendLine("| --- | --- | --- |")
        serviceProjects.forEach { project ->
            val dependsOn = mesh.getValue(project)
            val displayDependencies = if (dependsOn.isEmpty()) "_None_" else dependsOn.joinToString(", ") { "`${it.name}`" }
            val version = project.version.toString().ifBlank { "unspecified" }
            builder.appendLine("| `${project.name}` | $version | $displayDependencies |")
        }
        builder.appendLine()
        builder.appendLine("```mermaid")
        builder.appendLine("graph TD")
        val nodeIds = mutableMapOf<Project, String>()
        serviceProjects.forEachIndexed { index, project ->
            val nodeId = "S$index"
            nodeIds[project] = nodeId
            val label = "${project.name} ${project.version}".trim()
            builder.appendLine("    $nodeId[\"$label\"]")
        }
        mesh.forEach { (project, dependencies) ->
            dependencies.forEach { dependency ->
                builder.appendLine("    ${nodeIds.getValue(project)} --> ${nodeIds.getValue(dependency)}")
            }
        }
        builder.appendLine("```")
        builder.appendLine()
        builder.appendLine("Run `./gradlew generateServiceMesh` after modifying inter-service dependencies to refresh this document.")

        outputFile.asFile.writeText(builder.toString())
        logger.lifecycle("Wrote service dependency mesh documentation to ${outputFile.asFile.relativeTo(rootProject.projectDir)}")
    }
}

tasks.register("generateArchitectureDoc") {
    group = "documentation"
    description = "Generates a platform architecture overview at design/architecture.md."
    val outputFile = layout.projectDirectory.file("design/architecture.md")
    outputs.file(outputFile)

    doLast {
        val serviceProjects = serviceProjects()
        val mesh = serviceMesh(serviceProjects)
        val infrastructureLabels = mapOf(
            "mongo" to "MongoDB",
            "redis" to "Redis",
            "kafka" to "Kafka",
            "frontend" to "React Frontend"
        )
        val knownInfraKeys = setOf("mongo", "redis", "kafka")

        val composeServices = linkedMapOf<String, ComposeServiceInfo>()
        val dockerCompose = layout.projectDirectory.file("docker-compose.yml").asFile
        if (dockerCompose.exists()) {
            // Parse docker-compose.yml to map each service to its container, Dockerfile, and infrastructure dependencies.
            val lines = dockerCompose.readLines()
            var inServicesSection = false
            var currentService: ComposeServiceInfo? = null
            var inBuildBlock = false
            var inDependsOn = false
            var inEnvironment = false
            for (rawLine in lines) {
                val line = rawLine.trimEnd()
                val trimmed = line.trim()
                if (trimmed.isEmpty() || trimmed.startsWith("#")) continue
                if (!inServicesSection) {
                    if (trimmed == "services:") {
                        inServicesSection = true
                    }
                    continue
                }
                val indent = line.indexOfFirst { !it.isWhitespace() }.let { if (it == -1) 0 else it }
                if (indent == 0 && trimmed.endsWith(":") && trimmed != "services:") {
                    currentService = null
                    inBuildBlock = false
                    inDependsOn = false
                    inEnvironment = false
                    inServicesSection = false
                    continue
                }
                if (indent == 2 && trimmed.endsWith(":") && !trimmed.startsWith("-")) {
                    val serviceName = trimmed.removeSuffix(":")
                    currentService = composeServices.getOrPut(serviceName) { ComposeServiceInfo(serviceName) }
                    inBuildBlock = false
                    inDependsOn = false
                    inEnvironment = false
                    continue
                }
                val service = currentService ?: continue

                if (indent == 4 && trimmed.startsWith("build:")) {
                    inBuildBlock = true
                    inDependsOn = false
                    inEnvironment = false
                    continue
                }
                if (inBuildBlock && indent <= 4) {
                    inBuildBlock = false
                }

                if (indent == 4 && trimmed.startsWith("depends_on:")) {
                    inDependsOn = true
                    inEnvironment = false
                    continue
                }
                if (inDependsOn && indent <= 4) {
                    inDependsOn = false
                }

                if (indent == 4 && trimmed.startsWith("environment:")) {
                    inEnvironment = true
                    inDependsOn = false
                    continue
                }
                if (inEnvironment && indent <= 4) {
                    inEnvironment = false
                }

                if (inDependsOn && indent >= 6) {
                    val dependencyName = when {
                        trimmed.startsWith("- ") -> trimmed.removePrefix("- ").trim()
                        trimmed.endsWith(":") -> trimmed.removeSuffix(":").trim()
                        else -> null
                    }
                    if (!dependencyName.isNullOrBlank()) {
                        service.dependsOn += dependencyName
                    }
                    continue
                }

                if (inBuildBlock && indent >= 6 && trimmed.startsWith("dockerfile:")) {
                    service.dockerfile = trimmed.substringAfter("dockerfile:").trim()
                    continue
                }

                if (indent == 4 && trimmed.startsWith("container_name:")) {
                    service.containerName = trimmed.substringAfter("container_name:").trim()
                    continue
                }

                if (inEnvironment && indent >= 6) {
                    val entry = trimmed.removePrefix("- ").trim()
                    val value = entry.substringAfter("=", "").trim()
                    val hostCandidate = value.substringBefore(",").substringBefore(":").substringBefore("/").trim()
                    if (hostCandidate.isNotEmpty() && hostCandidate in knownInfraKeys) {
                        service.inferredInfra += hostCandidate
                    }
                }
            }
        }

        val composeByName = composeServices.toMap()
        val projectToComposeName = serviceProjects.associateWith { project ->
            composeByName.values.firstOrNull { compose ->
                compose.dockerfile?.contains("services/${project.name}/", ignoreCase = false) == true
            }?.name ?: project.name
        }
        val composeNameToProject = projectToComposeName.entries.associate { (project, composeName) -> composeName to project }
        val containerToProject = projectToComposeName.mapNotNull { (project, composeName) ->
            val compose = composeByName[composeName] ?: return@mapNotNull null
            val container = compose.containerName ?: compose.name
            container to project
        }.toMap()

        // Parse nginx.conf to connect the reverse proxy to backend services and frontend assets.
        val nginxFile = layout.projectDirectory.file("nginx.conf").asFile
        val upstreamTargets = mutableMapOf<String, String>()
        val proxiedHosts = linkedSetOf<String>()
        if (nginxFile.exists()) {
            var currentUpstream: String? = null
            for (rawLine in nginxFile.readLines()) {
                val line = rawLine.trim()
                when {
                    line.startsWith("upstream ") && line.endsWith("{") -> {
                        currentUpstream = line.removePrefix("upstream ").substringBefore(" ").trim()
                    }
                    currentUpstream != null && line == "}" -> {
                        currentUpstream = null
                    }
                    currentUpstream != null && line.startsWith("server ") -> {
                        val target = line.removePrefix("server ").substringBefore(";").trim()
                        val host = target.substringBefore(":").trim()
                        upstreamTargets[currentUpstream!!] = host
                    }
                }
                if (line.startsWith("proxy_pass ")) {
                    val target = line.substringAfter("proxy_pass").substringAfter("http://").substringBefore(";").trim()
                    val host = target.substringBefore("/").trim()
                    if (host.isNotEmpty()) {
                        proxiedHosts += upstreamTargets[host] ?: host
                    }
                }
            }
        }

        val nodeLabels = linkedMapOf<String, String>()
        val serviceNodeIds = serviceProjects.mapIndexed { index, project ->
            val nodeId = "S$index"
            nodeLabels[nodeId] = "${project.name} ${project.version}".trim()
            project to nodeId
        }.toMap()
        val infraNodeIds = linkedMapOf<String, String>()
        val edges = linkedSetOf<Pair<String, String>>()

        fun registerInfraNode(key: String, label: String): String =
            infraNodeIds.getOrPut(key) {
                val id = "I${infraNodeIds.size}"
                nodeLabels[id] = label
                id
            }

        fun addEdge(from: String, to: String) {
            if (from != to) {
                edges += from to to
            }
        }

        // Service mesh edges (caller -> callee).
        mesh.forEach { (project, dependencies) ->
            val fromId = serviceNodeIds.getValue(project)
            dependencies.forEach { dependency ->
                addEdge(fromId, serviceNodeIds.getValue(dependency))
            }
        }

        // Connect services to infrastructure components such as MongoDB, Redis, and Kafka.
        val serviceComposeNames = projectToComposeName.values.toSet()
        projectToComposeName.forEach { (project, composeName) ->
            val compose = composeByName[composeName] ?: return@forEach
            val infraDeps = (compose.dependsOn + compose.inferredInfra).filter { it in knownInfraKeys }
            val fromId = serviceNodeIds.getValue(project)
            infraDeps.sorted().forEach { infraKey ->
                if (infraKey !in serviceComposeNames) {
                    val label = formatInfraLabel(infraKey, infrastructureLabels)
                    val infraId = registerInfraNode(infraKey, label)
                    addEdge(fromId, infraId)
                }
            }
        }

        val reverseProxyId = registerInfraNode("reverse-proxy", "Reverse Proxy (nginx)")
        val externalClientsId = registerInfraNode("external-clients", "External Clients")
        addEdge(externalClientsId, reverseProxyId)

        // Orient reverse proxy outputs toward services and frontend assets.
        proxiedHosts.forEach { host ->
            val targetProject = containerToProject[host] ?: composeNameToProject[host]
            val targetId = if (targetProject != null) {
                serviceNodeIds[targetProject]
            } else {
                val label = formatInfraLabel(host, infrastructureLabels)
                registerInfraNode(host, label)
            }
            if (targetId != null) {
                addEdge(reverseProxyId, targetId)
            }
        }

        val builder = StringBuilder()
        builder.appendLine("# Platform Architecture")
        builder.appendLine()
        builder.appendLine("> Generated by `./gradlew generateArchitectureDoc`. Do not edit manually.")
        builder.appendLine()
        builder.appendLine("This document visualizes the relationships between Beacon services, shared infrastructure, and public ingress.")
        builder.appendLine()
        builder.appendLine("## Service and Infrastructure Graph")
        builder.appendLine()
        builder.appendLine("```mermaid")
        builder.appendLine("graph LR")
        nodeLabels.forEach { (id, label) ->
            builder.appendLine("    $id[\"$label\"]")
        }
        edges.forEach { (from, to) ->
            builder.appendLine("    $from --> $to")
        }
        builder.appendLine("```")
        builder.appendLine()
        builder.appendLine("Service nodes show semantic versions. Infrastructure nodes highlight shared dependencies and ingress routing, including MongoDB, Redis, Kafka, and the reverse proxy that fronts external traffic.")

        outputFile.asFile.writeText(builder.toString())
        logger.lifecycle("Wrote architecture overview to ${outputFile.asFile.relativeTo(rootProject.projectDir)}")
    }
}
